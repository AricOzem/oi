#Code[VS] 1017 乘积最大
##Description

今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰90周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友XZ也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：
设有一个长度为N的数字串，要求选手使用K个乘号将它分成K+1个部分，找出一种分法，使得这K+1个部分的乘积能够为最大。
同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：
有一个数字串：312， 当N=3，K=1时会有以下两种分法：

3*12=36
31*2=62
这时，符合题目要求的结果是：31*2=62
现在，请你帮助你的好朋友XZ设计一个程序，求得正确的答案。

##Input

程序的输入共有两行：
第一行共有2个自然数N，K（6≤N≤40，1≤K≤6）
第二行是一个长度为N的数字串。

##Output

结果显示在屏幕上，相对于输入，应输出所求得的最大乘积（一个自然数）。

##Solve

很诡异的一道题，想了很久才看懂
对于长度为n的字符序列。对于字符序列c1,c2,……,ci，（0=<i<n），插入j个“*”后形成最大乘积，用f[i][j]表示。
假设第j个“*”的插入位置是cl(之后),那么可以证明，对于c1,c2,……,cl,(0<=l<i),插入j-1个“*”也形成一个最大乘积f[l][j-1](其实就是废话,由结论推前一步)。
然后我们可以得到这个动态规划方程f[i][j]=max(f[i][j],f[l][j-1]*num[l+1][i])（1<=l<i）

```cpp
#include<cstdio>
int n,k;
char c[50];
long long num[50][50];
long long f[50][6];
inline long long max(long long a,long long b){
    return a &gt; b ? a : b;
}
inline long long solve_dp(){
    int i,j,l;
    for(int j=1;j&lt;=k;j++){
        for(int i=1;i&lt;=n;i++){
            for(l=1;l&lt;i;l++){
                f[i][j]=max(f[i][j],f[l][j-1]*num[l+1][i]);
            }
        }
     }
     return f[n][k];
}
int main(){
    scanf("%d%d",&amp;n,&amp;k);
    scanf("%s",&amp;c);
    for(int i=1;i&lt;=n;i++){//预处理
        for(int j=i;j&lt;=n;j++){
            num[i][j]=num[i][j-1]*10+c[j-1]-'0';
        }
        f[i][0]=num[1][i];
    }
    printf("%lld\n",solve_dp());
    return 0;
}
```

去网上查了一下该题的不同解法，发现还有一种比较神奇的方法不妨一试

>这里我有算法 我命名为“细胞竞争分裂法” 具体实现我已经用JAVA做出了 经过测试 跟穷举法得出的结果是一致的 而时间复杂度没有仔细算过 但绝对是P解法 比穷举法好很多 60多个数字 40个乘号 一点即出结果
具体思路如下：
1、把数字串视为细胞，它有一个最大乘积点，这样分裂了成两个细胞；
2、重复第一步，把分裂出来的两个细胞各自求出最大乘积点，然后用各自的乘积除以各自的数字串，比率最大的分裂；
3、重复第三步，直到乘号数为0；

>举个例子：数字串“399987”，两个乘号
这个数字串的最大的乘积点是“399*987”，第一个乘号插在这，然后分裂成两个子数字串“399”和“987”，这两个子数字串各自的最大的乘积点分别是“39*9”和“9*87”，这个时候选择谁插入呢？
用39*9/399和9*87/987比较，哪个比率最大，就选择这个插入。插入之后继续算出分裂出来的两个子细胞的最大乘积点和比率，以此类推。这个例子是39*9/399大，因此最后结果是：39*9*987

>这个算法不是乱来的，是可以推导的。至于代码我就不贴出了。
说起来，这个题用递归+暴力穷举让人蛋疼，经测试，数字串长度超过30，乘号数10，就已经out of memory了，就算改进一下空间复杂度，穷举始终是非P问题，等得让人蛋疼。
---by lwa6666 from http://bbs.csdn.net/topics/3000517254

##Source
NOIP2000