#Code[VS]1098 均分纸牌

##Description
有 N 堆纸牌，编号分别为 1，2，…, N。每堆上有若干张，但纸牌总数必为 N 的倍数。可以在任一堆上取若于张纸牌，然后移动。

移牌规则为：在编号为 1 堆上取的纸牌，只能移到编号为 2 的堆上；在编号为 N 的堆上取的纸牌，只能移到编号为 N-1 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。

现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。

例如 N=4，4 堆纸牌数分别为：
①　9　②　8　③　17　④　6

移动3次可达到目的：

从 ③ 取 4 张牌放到 ④ （9 8 13 10） -> 从 ③ 取 3 张牌放到 ②（9 11 10 10）-> 从 ② 取 1 张牌放到①（10 10 10 10）。

##Input

第一行N（N 堆纸牌，1 <= N <= 100）
第二行A1 A2 … An （N 堆纸牌，每堆纸牌初始数，l<= Ai<=10000）

##Output

输出至屏幕。格式为：
所有堆均达到相等时的最少移动次数。

##Solve

注意到第一堆纸牌只能向右移动，所以只要其纸牌没有达到平均值，必定只能将其“多余”的纸牌向右移动，因为其“多出来的”纸牌可能为负，所以我们来想象一下纸牌可以为负数的情况。考虑如下事实。

对于最左边的纸牌，为了使它的纸牌数达到平均，只要还没有达到平均无论其余子情况如何移动，一定有一步是把自己多余的纸牌移动到右边，或者是从右边移动进来自己差了多少张纸牌
第一堆牌只有和右边进行交互是合法的，步骤1是必须的
处理好第一堆后，其余操作一定不涉及第一堆，否则答案更劣（经过前一堆是没有意义的）
无视第一堆，于是现在又是情况1了（子结构）
对于一个会出现负数的方案，通过调整移动顺序，一定可以转变为一个不出现负数的方案。
根据贪心选择最优子结构，我们可以写出如下程序

```cpp
#include<cstdio>
int n,tot,ans;
int card[101];
inline void slove_greedy()
{
	int mid=tot/n;//计算平均值 
	for(int i=0;i<n;i++)//从左向右 
	{
		if(card[i]<mid){ card[i+1]-=mid-card[i]; card[i]=mid; ans++; } else if(card[i]>mid){
			card[i+1]+=card[i]-mid;
			ans++;
			card[i]=mid;
		}
	}
}
int main() {
	scanf("%d",&n);
	for(int i=0; i&lt;n; i++) {
		scanf(&quot;%d&quot;,&amp;card[i]);
		tot+=card[i];
	}
	slove_greedy();
	printf("%d",ans);
	return 0;
}
```