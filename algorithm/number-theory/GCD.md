# 第一章 欧几里得·扩展欧几里得

## 1 欧几里得算法

也就是辗转相除法，是为了求两个正整数的最大公因数

### 1.1 算法步骤

![](/assets/images/Euclidean-algorithm.svg)

Tip:此处“=”为赋值符号

### 1.2 简单证明\(摘自百度百科\)：

1. a可以表示成a = kb + r（a，b，k，r皆为正整数），则r = a mod b

2. 假设d是a,b的一个公约数，记作d\|a,d\|b，即a和b都可以被d整除。 而r = a -

   kb，两边同时除以d，r/d=a/d-kb/d=m，等式左边可知m为整数，因此d\|r 因此d也是（b,a mod b）的公约数

3. 因此（a,b）和（b,a mod b）的公约数是一样的，其最大公约数也必然相等，得证。

```cpp
int gcd(int a,int b){
   if(b==0)return a;
   gcd(b,a%b);
}
```

## 2 扩展欧几里得算法

扩展欧几里得算法是欧几里得算法（又叫辗转相除法）的扩展。（看名字就知道了←\_←）

他的出现是为了解决这个方程 ax+by=gcd\(a,b\)

### 2.1 裴蜀等式

为什么要解决它呢 因为有个人叫裴蜀他提出了这个等式

ax + by = m

对任何整数a、b和它们的最大公约数d，关于未知数x和y的线性丢番图方程（称为裴蜀等式）：

有解当且仅当m是d的倍数。

裴蜀等式有解时必然有无穷多个整数解，每组解x、y都称为裴蜀数，就是用我们的扩展欧几里得算法得出的。

### 2.2 算法步骤

那么他是怎么做到的呢？

我们举一个非常特殊的例子：

当上面欧几里得算法到达最终局面时，即 a=gcd b=0 时\(gcd等于最初输入数的最大公因数\)

此时，我们可以用“观察法”看出方程一个显然的解 x=1 y=0 因为 1\*gcd+0\*0=gcd \(当然y为任何数都行\)

那我们是不是可以倒着追溯回去，求出上一步的ax+by=gcd 的解呢。没错，这就是扩展欧几里得的核心思想。

具体怎么转换状态的呢，我们可以看其中两个步骤

$$\because \gcd(a,b)=\gcd(b,a \mod b)$$

$$\therefore ax_1+by_1=bx_2+(a \mod b)y_2$$

$$\therefore ax_1+by_1=bx_2+(a- \lfloor\frac{a}{b}\rfloor*b)y_2$$

因为左右两边恒等，所以我们发现上一层的x等于下一层y,上一层的y等于下一层的$$(a-\lfloor\frac{a}{b}\rfloor*b)y_2$$

```cpp
int exgcd(int a,int b,int &x,int &y){
   if(b==0){x=1;y=0;return a;}
   exgcd(b,a%b,x,y);
   int t=y;y=x-a/b*y;x=t;
}
```

### 2.3 扩展欧几里得算法的应用

1.[\[NOIP2012\] 同余方程](/CodeVS/p1200.md) 求乘法逆元

