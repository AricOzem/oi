# Luogu 1472 奶牛家谱 Cow Pedigrees (USACO 2.3.2) 
## Description

农民约翰准备购买一群新奶牛。 在这个新的奶牛群中, 每一个母亲奶牛都生两个小奶牛。这些奶牛间的关系可以用二叉树来表示。这些二叉树总共有N个节点(3 &lt;= N &lt; 200)。这些二叉树有如下性质:

每一个节点的度是0或2。度是这个节点的孩子的数目。

树的高度等于K(1 &lt; K &lt; 100)。高度是从根到最远的那个叶子所需要经过的结点数; 叶子是指没有孩子的节点。

有多少不同的家谱结构? 如果一个家谱的树结构不同于另一个的, 那么这两个家谱就是不同的。输出可能的家谱树的个数除以9901的余数。

## Input
两个空格分开的整数, N和K。

##　Output
一个整数，表示可能的家谱树的个数除以9901的余数。

输入输出样例

## Sample Input
```
5 3
```
## Sample Output 
```
2
```
## Hint
```
有5个节点，高为3的两个不同的家谱：
         @                                 @
        / \                               / \
       @   @            和               @   @
      / \                                   / \
     @   @                                 @   @
```
## Solve
考虑一个高为k，结点数为n的二叉树，去掉根得到两个数的大小为p 和 n-1-p 对于每个p，方案数为高度为k-1，节点数为p的方案数*高度为k-1，节点数为n-1-p的方案数。然后我们就可以缩小问题进行dp了。因为刚好层数为k比较复杂，我们可以考虑进行前缀和。
```cpp
#include<cstdio>
#define MOD 9901
int n,_k;
int f[110][200];//深度小于等于k 人数为n 的 情况数 
int main(){
    scanf("%d%d",&n,&_k);
    for(int i=1;i<=_k;i++) f[i][1]=1;
    for(int i=2;i<=_k;i++)
		for(int j=3;j<=n;j+=2)
			for(int k=1;k<=j-2;k+=2)
				f[i][j]=(f[i][j]+f[i-1][k]*f[i-1][j-1-k])%MOD;
	printf("%d",(f[_k][n]-f[_k-1][n]+MOD)%MOD);
    return 0;
}
```